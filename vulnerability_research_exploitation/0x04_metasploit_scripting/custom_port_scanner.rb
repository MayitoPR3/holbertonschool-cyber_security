require 'msf/core'

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Custom Port Range Scanner',
      'Description'    => %q{
        Metasploit auxiliary module that scans a range of ports on a 
        target system and identifies which ones are open.
      },
      'Author'         => [ 'Jose Mayo' ],
      'License'        => MSF_LICENSE,
      'References'     => []
    ))

    register_options(
      [
        Opt::RHOST(),                              # single host convenience (Scanner will accept RHOSTS too)
        OptInt.new('STARTPORT', [ true, 'Start port to scan', 1 ]),
        OptInt.new('ENDPORT',   [ true, 'End port to scan',   1024 ]),
        OptInt.new('TIMEOUT',   [ true, 'Connection timeout (seconds)', 5 ])
      ]
    )

    register_advanced_options(
      [
        OptInt.new('THREADS', [ false, 'Number of threads for the scanner (Scanner mixin handles this)', 10 ])
      ]
    )
  end

  #
  # run_host is invoked by the Scanner mixin for each target host (supports RHOSTS)
  #
  def run_host(host)
    start_port = datastore['STARTPORT'].to_i
    end_port   = datastore['ENDPORT'].to_i
    timeout    = datastore['TIMEOUT'].to_i

    # small safety checks
    if start_port < 1
      start_port = 1
    end
    if end_port > 65535
      end_port = 65_535
    end
    if end_port < start_port
      print_error("ENDPORT #{end_port} is less than STARTPORT #{start_port} - skipping #{host}")
      return
    end

    open_ports = []

    print_status("Running module against #{host}")

    (start_port..end_port).each do |port|
      begin
        # Attempt to create a TCP connection
        sock = Rex::Socket::Tcp.create(
          'PeerHost'      => host,
          'PeerPort'      => port,
          'ConnectTimeout'=> timeout,
          'Context'       => { 'Msf' => framework, 'MsfExploit' => self }
        )

        # If we got a socket, the port is open. Close socket and report.
        if sock
          sock.close
          print_good("#{host}:#{port} - Port #{port} is open on #{host}")
          open_ports << port

          # Report the service to the database (useful in the workspace)
          begin
            report_service(
              :host => host,
              :port => port,
              :proto => 'tcp',
              :name => 'unknown',
              :info => 'open'
            )
          rescue ::Exception
            # don't let reporting failure stop scanning
          end
        end

      rescue ::Rex::ConnectionError
        # connection failed -> port closed/unreachable; do nothing
      rescue ::Interrupt
        raise $!   # allow ctrl-c to bubble up
      rescue ::Exception => e
        # Catch-all to avoid crashing the module on unexpected errors
        vprint_error("Error scanning #{host}:#{e.class} #{e}")
      end
    end

    if open_ports.any?
      print_status("#{host} - Open ports on #{host}: #{open_ports.join(', ')}")
    else
      print_status("#{host} - No open ports found in range #{start_port}-#{end_port}")
    end
  end
end
