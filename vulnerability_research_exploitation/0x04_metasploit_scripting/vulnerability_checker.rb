require 'msf/core'

class MetasploitModule < Msf::Auxiliary
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'MS17-010 Vulnerability Checker (wrapper)',
      'Description' => %q{
        Checks if a target is vulnerable to MS17-010 (EternalBlue).
        This module prefers to delegate the check to Metasploit's built-in
        auxiliary/scanner/smb/smb_ms17_010 if available. If that module is not present,
        it falls back to a heuristic TCP/445 check (which is not definitive).
      },
      'Author'      => ['Jose Mayo'],
      'License'     => MSF_LICENSE
    ))

    register_options(
      [
        Opt::RHOST(),
        OptInt.new('RPORT', [ true, 'SMB port', 445 ]),
        OptBool.new('USE_BUILTIN', [ true, 'Prefer using built-in smb_ms17_010 if available', true ]),
        OptInt.new('TIMEOUT', [ true, 'TCP connect timeout', 5 ])
      ]
    )
  end

  #
  # run_host invoked by Scanner mixin for each host
  #
  def run_host(host)
    rport   = datastore['RPORT'].to_i
    timeout = datastore['TIMEOUT'].to_i

    print_status("Checking #{host} for MS17-010 vulnerability")

    if datastore['USE_BUILTIN']
      # Try to find the builtin smb_ms17_010 scanner in the framework
      begin
        # The module path in Metasploit is 'auxiliary/scanner/smb/smb_ms17_010'
        if framework && framework.modules
          mod_ref = framework.modules.module_exists?('auxiliary', 'scanner', 'smb', 'smb_ms17_010')
        else
          mod_ref = false
        end
      rescue ::Exception
        mod_ref = false
      end

      if mod_ref
        # Instantiate and run the official scanner module programmatically.
        # Note: executing another module programmatically from a module is somewhat
        # fragile across Metasploit versions (APIs change). This code attempts to
        # run the module and parse its datastore return values (best-effort).
        begin
          scanner = framework.modules.create('auxiliary', 'scanner', 'smb', 'smb_ms17_010')
          scanner.datastore['RHOSTS'] = host
          scanner.datastore['RPORT']  = rport
          # keep single-threaded for predictable behavior
          scanner.datastore['THREADS'] = 1 if scanner.datastore.key?('THREADS')

          print_status("Delegating check to auxiliary/scanner/smb/smb_ms17_010 for #{host}")
          # run the module â€” some Metasploit versions support run_simple; fallback to run.
          if scanner.respond_to?(:run_simple)
            # run_simple returns a result hash sometimes; we only care about output in console
            scanner.run_simple(
              'AGGRESSIVE' => false,
              'LocalInput' => nil,
              'LocalOutput'=> nil
            )
            # The official module prints its own output; attempt to read its reported services
            print_good("#{host} - check delegated to smb_ms17_010 (see module output above).")
            return
          else
            # If run_simple isn't present, attempt to call run (this may block behave differently)
            scanner.run
            print_good("#{host} - check delegated to smb_ms17_010 (see module output above).")
            return
          end
        rescue ::Exception => e
          vprint_error("Failed to delegate to smb_ms17_010: #{e.class} #{e}")
          # Fall back to heuristic below
        end
      else
        vprint_status("Built-in auxiliary/scanner/smb/smb_ms17_010 not found in this framework - using fallback heuristic.")
      end
    end

    #
    # Fallback heuristic: check TCP/445 reachability (NOT a definitive MS17-010 test)
    # - This is useful as a quick indicator but will produce false positives.
    # - Recommend using the built-in Metasploit smb_ms17_010 scanner for a proper test.
    #
    begin
      sock = nil
      begin
        sock = Rex::Socket::Tcp.create(
          'PeerHost' => host,
          'PeerPort' => rport,
          'ConnectTimeout' => timeout,
          'Context' => { 'Msf' => framework, 'MsfExploit' => self }
        )
      rescue ::Rex::ConnectionError
        sock = nil
      end

      if sock
        sock.close
        print_good("#{host} is reachable on TCP/#{rport}.")
        print_status("WARNING: This module could not invoke the built-in smb_ms17_010 scanner; the presence of TCP/#{rport} alone is NOT proof of MS17-010 vulnerability.")
        print_status("If you have a full Metasploit installation, prefer: auxiliary/scanner/smb/smb_ms17_010 (more accurate).")
        # Report only the reachability (heuristic)
        report_note(
          :host => host,
          :type => 'ms17_010_fallback_heuristic',
          :data => "TCP/#{rport} is open or reachable from this scanner (heuristic only).",
          :update => :unique
        )
      else
        print_status("#{host} is not reachable on TCP/#{rport} (closed / filtered).")
      end
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("Error checking #{host}: #{e.class} #{e}")
    end
  end
end
